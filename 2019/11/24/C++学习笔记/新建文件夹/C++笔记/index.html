
 <!DOCTYPE HTML>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  
    <title>C++ 学习笔记【长期更】 | p1Kk&#39;s World!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="p1Kk">
    

    
    <meta name="description" content="在有c语言基础下学习《C++ Primer》的新知  小知识okfine太繁杂了…我觉得写的太烂了…淦，后面二次学习的话就会精简一些了…吧…  9.7更1using namespace std;    使用std::虽然较麻烦，但是在大型程序中，很有必要。后期讲命名空间解释。 1. 在控制台窗口内编译程序假定main程序保存在文件prog1.cc中，用如下命令编译它： 1$ CC prog1.c">
<meta name="keywords" content="笔记,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 学习笔记【长期更】">
<meta property="og:url" content="p1Kk.github.io/2019/11/24/C++学习笔记/新建文件夹/C++笔记/index.html">
<meta property="og:site_name" content="p1Kk&#39;s World!">
<meta property="og:description" content="在有c语言基础下学习《C++ Primer》的新知  小知识okfine太繁杂了…我觉得写的太烂了…淦，后面二次学习的话就会精简一些了…吧…  9.7更1using namespace std;    使用std::虽然较麻烦，但是在大型程序中，很有必要。后期讲命名空间解释。 1. 在控制台窗口内编译程序假定main程序保存在文件prog1.cc中，用如下命令编译它： 1$ CC prog1.c">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://i.loli.net/2019/11/24/x4SgjiFKazNYLXo.png">
<meta property="og:image" content="https://i.loli.net/2019/11/25/Bs4dRg1XQOahGNw.png">
<meta property="og:image" content="https://i.loli.net/2019/11/25/6X1NBov4LlkmCqx.png">
<meta property="og:image" content="https://i.loli.net/2019/12/20/nIGr8XzN47U1vMg.png">
<meta property="og:image" content="https://i.loli.net/2019/12/20/dZbrz7DYC2vywJ3.png">
<meta property="og:image" content="https://i.loli.net/2019/12/20/jcWxpuADq3VtSEb.png">
<meta property="og:image" content="https://i.loli.net/2019/12/20/1rvbKlZmNpDwxyY.png">
<meta property="og:updated_time" content="2019-12-23T05:07:29.844Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 学习笔记【长期更】">
<meta name="twitter:description" content="在有c语言基础下学习《C++ Primer》的新知  小知识okfine太繁杂了…我觉得写的太烂了…淦，后面二次学习的话就会精简一些了…吧…  9.7更1using namespace std;    使用std::虽然较麻烦，但是在大型程序中，很有必要。后期讲命名空间解释。 1. 在控制台窗口内编译程序假定main程序保存在文件prog1.cc中，用如下命令编译它： 1$ CC prog1.c">
<meta name="twitter:image" content="https://i.loli.net/2019/11/24/x4SgjiFKazNYLXo.png">

    
    <link rel="alternative" href="atom.xml" title="p1Kk&#39;s World!" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/site.jpg">
    
    
    <link rel="apple-touch-icon" href="/img/head.png">
    <link rel="apple-touch-icon-precomposed" href="/img/head.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo2.jpg" alt="p1Kk&#39;s World!" title="p1Kk&#39;s World!"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="p1Kk&#39;s World!">p1Kk&#39;s World!</a></h1>
				<h2 class="blog-motto">艺无止境，功不唐捐。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
						<li><a href="/tags">Tags</a></li>
					
						<li><a href="/categories">Categories</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:p1Kk.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	
	  <article itemprop="articleBody"> 
		  <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/24/C++学习笔记/新建文件夹/C++笔记/" title="C++ 学习笔记【长期更】" itemprop="url">C++ 学习笔记【长期更】</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="p1Kk" target="_blank" itemprop="author">p1Kk</a>
		
  <p class="article-time">
    <time datetime="2019-11-23T16:00:00.000Z" itemprop="datePublished"> Published 2019-11-24</time>
    
  </p>
</header>
	  <div class="article-content">
		  
		  <div id="toc" class="toc-article">
			  <strong class="toc-title">Contents</strong>
		  
			  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#小知识"><span class="toc-number">1.</span> <span class="toc-text">小知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-在控制台窗口内编译程序"><span class="toc-number">1.1.</span> <span class="toc-text">1. 在控制台窗口内编译程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-输入输出流"><span class="toc-number">1.2.</span> <span class="toc-text">2. 输入输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-for循环和while循环的对比"><span class="toc-number">1.3.</span> <span class="toc-text">3.for循环和while循环的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-读取数据直到文件尾"><span class="toc-number">1.4.</span> <span class="toc-text">4.读取数据直到文件尾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-一旦选择了一种风格，就要坚持使用。"><span class="toc-number">1.5.</span> <span class="toc-text">5.一旦选择了一种风格，就要坚持使用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-能定义使用上像内置类型一样自然的类类型"><span class="toc-number">1.6.</span> <span class="toc-text">6.能定义使用上像内置类型一样自然的类类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-使用-include-lt-gt-“”"><span class="toc-number">1.7.</span> <span class="toc-text">7.使用#include&lt;&gt; // “”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-使用文件重定向"><span class="toc-number">1.8.</span> <span class="toc-text">8.使用文件重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-算术类型-amp-amp-空类型"><span class="toc-number">1.9.</span> <span class="toc-text">9.算术类型 &amp;&amp; 空类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-运算"><span class="toc-number">1.10.</span> <span class="toc-text">10.运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-’-‘-amp-“-“"><span class="toc-number">1.11.</span> <span class="toc-text">11.’ ‘ &amp; “ “</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-面向对象程序设计的思想"><span class="toc-number">1.12.</span> <span class="toc-text">12.面向对象程序设计的思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-初始化和赋值"><span class="toc-number">1.13.</span> <span class="toc-text">13.初始化和赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-列表初始化"><span class="toc-number">1.14.</span> <span class="toc-text">14.列表初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-默认初始化"><span class="toc-number">1.15.</span> <span class="toc-text">15.默认初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-分离式编译"><span class="toc-number">1.16.</span> <span class="toc-text">16.分离式编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-标识符"><span class="toc-number">1.17.</span> <span class="toc-text">17.标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-嵌套的作用域"><span class="toc-number">1.18.</span> <span class="toc-text">18.嵌套的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-引用（-amp-d，d是声明的变量）"><span class="toc-number">1.19.</span> <span class="toc-text">19.引用（&amp;d，d是声明的变量）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-空指针"><span class="toc-number">1.20.</span> <span class="toc-text">20.空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-赋值永远改变的是等号左侧的对象"><span class="toc-number">1.21.</span> <span class="toc-text">21.赋值永远改变的是等号左侧的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-两指针比较"><span class="toc-number">1.22.</span> <span class="toc-text">22.两指针比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-void-指针"><span class="toc-number">1.23.</span> <span class="toc-text">23.void* 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-指向指针的引用"><span class="toc-number">1.24.</span> <span class="toc-text">24.指向指针的引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-const限定符"><span class="toc-number">1.25.</span> <span class="toc-text">25.const限定符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-const的引用"><span class="toc-number">1.26.</span> <span class="toc-text">26.const的引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-指针和const"><span class="toc-number">1.27.</span> <span class="toc-text">27.指针和const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-非常量引用不能引用字面值常量"><span class="toc-number">1.28.</span> <span class="toc-text">28.非常量引用不能引用字面值常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-顶层-amp-amp-底层"><span class="toc-number">1.29.</span> <span class="toc-text">29.顶层 &amp;&amp; 底层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-constexpr和常量表达式"><span class="toc-number">1.30.</span> <span class="toc-text">30.constexpr和常量表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-定义类型别名"><span class="toc-number">1.31.</span> <span class="toc-text">31.定义类型别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-auto类型说明符"><span class="toc-number">1.32.</span> <span class="toc-text">32.auto类型说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-decltype类型指示符"><span class="toc-number">1.33.</span> <span class="toc-text">33.decltype类型指示符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-预处理器"><span class="toc-number">1.34.</span> <span class="toc-text">34.预处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-抽象数据类型库"><span class="toc-number">1.35.</span> <span class="toc-text">35.抽象数据类型库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-using"><span class="toc-number">1.36.</span> <span class="toc-text">36.using</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-include"><span class="toc-number">1.37.</span> <span class="toc-text">37.#include</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-getline"><span class="toc-number">1.38.</span> <span class="toc-text">38.getline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-处理string中的字符"><span class="toc-number">1.39.</span> <span class="toc-text">39.处理string中的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-范围for语句"><span class="toc-number">1.40.</span> <span class="toc-text">40.范围for语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-标准库类型vector"><span class="toc-number">1.41.</span> <span class="toc-text">41.标准库类型vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-迭代器"><span class="toc-number">1.42.</span> <span class="toc-text">42.迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-数组"><span class="toc-number">1.43.</span> <span class="toc-text">43.数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体"><span class="toc-number">1.44.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的重载和覆盖"><span class="toc-number">1.45.</span> <span class="toc-text">函数的重载和覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">1.46.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类"><span class="toc-number">1.47.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造器与析构器"><span class="toc-number">1.48.</span> <span class="toc-text">构造器与析构器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">1.49.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">1.50.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于endl和’-n’的区别"><span class="toc-number">1.51.</span> <span class="toc-text">关于endl和’\n’的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问控制"><span class="toc-number">1.52.</span> <span class="toc-text">访问控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#和java有点像喔…"><span class="toc-number">1.53.</span> <span class="toc-text">和java有点像喔…</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一些easy-test"><span class="toc-number">2.</span> <span class="toc-text">一些easy_test</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#读取文本"><span class="toc-number">2.1.</span> <span class="toc-text">读取文本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复制文本"><span class="toc-number">2.2.</span> <span class="toc-text">复制文本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串变大写！"><span class="toc-number">2.3.</span> <span class="toc-text">字符串变大写！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器运算小🌰子"><span class="toc-number">2.4.</span> <span class="toc-text">迭代器运算小🌰子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造器和析构器"><span class="toc-number">2.5.</span> <span class="toc-text">构造器和析构器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承-1"><span class="toc-number">2.6.</span> <span class="toc-text">继承</span></a></li></ol></li></ol>
		  
		  </div>
		  
		  <blockquote>
<p>在有c语言基础下学习《C++ Primer》的新知</p>
</blockquote>
<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><p>okfine太繁杂了…我觉得写的太烂了…淦，后面二次学习的话就会精简一些了…吧…</p>
<ul>
<li>9.7更<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用std::虽然较麻烦，但是在大型程序中，很有必要。后期讲命名空间解释。</p>
<h2 id="1-在控制台窗口内编译程序"><a href="#1-在控制台窗口内编译程序" class="headerlink" title="1. 在控制台窗口内编译程序"></a>1. 在控制台窗口内编译程序</h2><p>假定main程序保存在文件prog1.cc中，用如下命令编译它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CC prog1.cc</span><br></pre></td></tr></table></figure>

<p>其中，CC为编译器程序的名字，$是系统提示符。</p>
<h2 id="2-输入输出流"><a href="#2-输入输出流" class="headerlink" title="2. 输入输出流"></a>2. 输入输出流</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; 变量名;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cin &gt;&gt;  其中&gt;&gt;最初定义为右移操作符<br>体现了重载<br>理解为 从cin内部缓冲区中提取信息<br>&lt;&lt;同理</p>
</blockquote>
<p>一些函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cin.ignore</span><br><span class="line">cin.getline</span><br><span class="line">cin.peek</span><br><span class="line">cin.get</span><br><span class="line">cin.read</span><br><span class="line">cin.gcount</span><br><span class="line">cin.write</span><br><span class="line">----------------------------------------------</span><br><span class="line">cin.eof()：如果到达文件（或输入）末尾，返回true</span><br><span class="line">cin.fail()：如果cin无法工作，返回true</span><br><span class="line">cin.bad()：如果cin因为比较严重的原因（例如内存不足）而无法工作，返回true</span><br><span class="line">cin.good()：以上情况都没有发生。返回true</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;字符串字面常量&quot; &lt;&lt; 变量运算 &lt;&lt; endl;</span><br><span class="line">               |              |</span><br><span class="line">                    可有可无</span><br></pre></td></tr></table></figure>

<p>一些函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout. precision</span><br><span class="line">cout. width</span><br></pre></td></tr></table></figure>

<p>想象一下，<code>cin&gt;&gt;x</code><br>就是从输入流给到x<br><code>cout&lt;&lt;x</code><br>就是x给输出流<br>这样好记住用<code>&lt;&lt;</code>还是<code>&gt;&gt;</code></p>
<h2 id="3-for循环和while循环的对比"><a href="#3-for循环和while循环的对比" class="headerlink" title="3.for循环和while循环的对比"></a>3.for循环和while循环的对比</h2><p>在循环次数已知的情况下，for循环的形式更简洁。<br>循环次数无法预知时，用while循环实现更适合。<br>用特定条件控制循环是否执行，循环体中执行的语句可能导致循环判定条件发生变化。</p>
<h2 id="4-读取数据直到文件尾"><a href="#4-读取数据直到文件尾" class="headerlink" title="4.读取数据直到文件尾"></a>4.读取数据直到文件尾</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(cin &gt;&gt; value)</span><br></pre></td></tr></table></figure>

<p>直接对输入流cin进行检测<br><strong>其中键入时，windows系统中，输入文件结束符的方法是Ctrl+Z，然后按Enter或Return<br>在unix系统和Mac OS X系统中，文件结束符的输入是Ctrl+D</strong></p>
<h2 id="5-一旦选择了一种风格，就要坚持使用。"><a href="#5-一旦选择了一种风格，就要坚持使用。" class="headerlink" title="5.一旦选择了一种风格，就要坚持使用。"></a>5.一旦选择了一种风格，就要坚持使用。</h2><p>really？？？嘻嘻，觉得想换就可以改进嘛</p>
<h2 id="6-能定义使用上像内置类型一样自然的类类型"><a href="#6-能定义使用上像内置类型一样自然的类类型" class="headerlink" title="6.能定义使用上像内置类型一样自然的类类型"></a>6.能定义使用上像内置类型一样自然的类类型</h2><p>给的Sales_item.h头文件 网址==<a href="http://www.informit.com/store/c-plus-plus-primer-9780321714114" target="_blank" rel="noopener">http://www.informit.com/store/c-plus-plus-primer-9780321714114</a>，是卖书的。。。<br>没搞明白呢？先打个❓</p>
<hr>
<ul>
<li>9.8更</li>
</ul>
<h2 id="7-使用-include-lt-gt-“”"><a href="#7-使用-include-lt-gt-“”" class="headerlink" title="7.使用#include&lt;&gt; // “”"></a>7.使用#include&lt;&gt; // “”</h2><p>包含来自标准库的头文件时，应该用<code>&lt; &gt;</code>包围头文件名。对于不属于标准库的头文件，则使用<code>&quot; &quot;</code>包围<br>（在学习c语言的时候，没有太注意&lt;&gt;和””的区别）</p>
<h2 id="8-使用文件重定向"><a href="#8-使用文件重定向" class="headerlink" title="8.使用文件重定向"></a>8.使用文件重定向</h2><p>测试程序时，允许我们将标准输入和标准输出与命名文件关联起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ addItems &lt;infile &gt;outfile</span><br><span class="line">|     |        |       |</span><br><span class="line">|  可执行文件   |       |</span><br><span class="line">系统提示符     从infile中读取将输出结果写入outfile</span><br></pre></td></tr></table></figure>

<h2 id="9-算术类型-amp-amp-空类型"><a href="#9-算术类型-amp-amp-空类型" class="headerlink" title="9.算术类型 &amp;&amp; 空类型"></a>9.算术类型 &amp;&amp; 空类型</h2><p>算术类型分为两类：<strong>整型</strong>（包括<strong>字符</strong>和<strong>布尔类型</strong>在内）和<strong>浮点型</strong></p>
<h2 id="10-运算"><a href="#10-运算" class="headerlink" title="10.运算"></a>10.运算</h2><p>c语言没有注意过，但是这是个漏洞点哟<br>当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数<br>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned u = 10;</span><br><span class="line">	int i = -42;</span><br><span class="line">	cout &lt;&lt; i + i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; u + i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-84</span><br><span class="line">4294967264</span><br></pre></td></tr></table></figure>

<p>相加前先把整数-42转换成无符号数，</p>
<hr>
<ul>
<li>9.10更</li>
</ul>
<p>今天觉得自己c语言学的真粗糙，嘿嘿</p>
<h2 id="11-’-‘-amp-“-“"><a href="#11-’-‘-amp-“-“" class="headerlink" title="11.’ ‘ &amp; “ “"></a>11.’ ‘ &amp; “ “</h2><p>例如：字面值’A’表示的是单独的字母A，而字符串”A”则代表了一个字符的数组，该数组包含两个字符：一个是字母A，另一个是空字符（’\0’）</p>
<h2 id="12-面向对象程序设计的思想"><a href="#12-面向对象程序设计的思想" class="headerlink" title="12.面向对象程序设计的思想"></a>12.面向对象程序设计的思想</h2><p>通常情况下，<strong>对象</strong>是指一块能存储数据并具有某种类型的内存空间。<br>更加细致可以参考：<a href="https://blog.csdn.net/jerry11112/article/details/79027834" target="_blank" rel="noopener">面向对象与面向过程的本质的区别</a></p>
<h2 id="13-初始化和赋值"><a href="#13-初始化和赋值" class="headerlink" title="13.初始化和赋值"></a>13.初始化和赋值</h2><p>在C++语言中，初始化和赋值是两个完全不同的操作。然而在很多编程语言中二者的区别几乎可以忽略不计，即使在C++中有时这种区别也无关紧要，但是需要强调的是，这个概念至关重要，后面会经常提到。<br>初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p>
<h2 id="14-列表初始化"><a href="#14-列表初始化" class="headerlink" title="14.列表初始化"></a>14.列表初始化</h2><p>要想定义一个名为units_sold的int变量并初始化为0，可以使用一下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int units_sold = 0;</span><br><span class="line">int units_sold = &#123;0&#125;;</span><br><span class="line">int units_sold&#123;0&#125;;</span><br><span class="line">int units_sold(0);</span><br></pre></td></tr></table></figure>

<h2 id="15-默认初始化"><a href="#15-默认初始化" class="headerlink" title="15.默认初始化"></a>15.默认初始化</h2><p>如果内置类型的变量未被显式初始化，则：<br>1.定义于任何函数体之外的变量被初始化为0。<br>2.定义在函数体内部的内置类型变量将不被初始化，此时试图拷贝或以其他形式访问此类值将引发错误。<br>3.绝大多数类都支持无需显式初始化而定义对象，如string类规定如果没有指定处值则生成一个空串。<br>4.一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而没有明确初始化操作，则引发错误。</p>
<h2 id="16-分离式编译"><a href="#16-分离式编译" class="headerlink" title="16.分离式编译"></a>16.分离式编译</h2><p>c++支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern int i;    //声明而非定义</span><br><span class="line">int j;    //声明并定义</span><br><span class="line">extern double pi = 3.14159;    //定义</span><br></pre></td></tr></table></figure>

<p>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。<br>如果要在多个文件中使用同一个变量，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>
<h2 id="17-标识符"><a href="#17-标识符" class="headerlink" title="17.标识符"></a>17.标识符</h2><p>必须以字母或下划线开头<br>用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头<br>定义在函数体外的标识符不能以下划线开头</p>
<h2 id="18-嵌套的作用域"><a href="#18-嵌套的作用域" class="headerlink" title="18.嵌套的作用域"></a>18.嵌套的作用域</h2><p>使用<a href="https://blog.csdn.net/qq_33266987/article/details/53689133" target="_blank" rel="noopener"><strong>作用域运算符</strong>（<strong>::</strong>）</a><br>在本例中表示显式地访问全局变量<br>eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int reused = 42;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int unique = 0;</span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	int reused = 0;</span><br><span class="line">	//使用局部变量reused，此时变量in scope</span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	//显式访问全局变量reused</span><br><span class="line">	std::cout &lt;&lt; ::reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">42 0</span><br><span class="line">0 0</span><br><span class="line">42 0</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>9.11更</li>
</ul>
<h2 id="19-引用（-amp-d，d是声明的变量）"><a href="#19-引用（-amp-d，d是声明的变量）" class="headerlink" title="19.引用（&amp;d，d是声明的变量）"></a>19.引用（&amp;d，d是声明的变量）</h2><p>定义引用时，程序把引用和它的初始值<strong>绑定（bind）</strong>在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。</p>
<hr>
<ul>
<li>9.12放假划水了一天… </li>
<li>9.13更</li>
</ul>
<h2 id="20-空指针"><a href="#20-空指针" class="headerlink" title="20.空指针"></a>20.空指针</h2><p>几种生成空指针的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = nullptr;</span><br><span class="line">int *p2 = 0;</span><br><span class="line">//需要首先#include cstdlib</span><br><span class="line">int *p3 = NULL;</span><br></pre></td></tr></table></figure>

<p><strong>NULL</strong>是一个预处理变量，在头文件cstdlib中定义。预处理变量不属于命名空间std。<br>在C++11新标准下，最好使用<strong>nullptr</strong>，同时尽量避免使用NULL。<br>把int变量直接赋给指针是错误的操作。</p>
<h2 id="21-赋值永远改变的是等号左侧的对象"><a href="#21-赋值永远改变的是等号左侧的对象" class="headerlink" title="21.赋值永远改变的是等号左侧的对象"></a>21.赋值永远改变的是等号左侧的对象</h2><p>尤其是对于指针这种，很容易迷惑<br>eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *pi = 0;  //pi被初始化为0</span><br><span class="line">pi = &amp;ival;  //pi指向ival</span><br><span class="line">*pi = 0;  //(*pi即pi指向的对象)ival发生改变</span><br></pre></td></tr></table></figure>

<h2 id="22-两指针比较"><a href="#22-两指针比较" class="headerlink" title="22.两指针比较"></a>22.两指针比较</h2><p>类型相同的指针比较结果为布尔型。<br>两个指针存放的地址值相同有三种可能：<br>1.它们都为空<br>2.都指向同一个对象<br>3.<strong>一个指针指向某对象，同时另一个指针指向另外对象的下一地址</strong></p>
<h2 id="23-void-指针"><a href="#23-void-指针" class="headerlink" title="23.void* 指针"></a>23.void* 指针</h2><p>void*能存放任意类型对象的地址。他能做的就是：和其他指针比较、作为函数输入输出、赋给另外一个void*指针。不能直接操作</p>
<h2 id="24-指向指针的引用"><a href="#24-指向指针的引用" class="headerlink" title="24.指向指针的引用"></a>24.指向指针的引用</h2><p>好复杂… 昏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">int *p;</span><br><span class="line">int *&amp;r = p;  //r是一个对指针p的引用</span><br><span class="line"></span><br><span class="line">r = &amp;i;  //r引用了一个指针，给r赋值&amp;i就是令p指向i</span><br><span class="line">*r = 0;  //解引用r得到i，也就是p指向的对象，将i的值改为0</span><br></pre></td></tr></table></figure>

<p>（从右向左阅读有助于弄清复杂指针或引用的声明语句的真实含义）</p>
<h2 id="25-const限定符"><a href="#25-const限定符" class="headerlink" title="25.const限定符"></a>25.const限定符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize = 512;</span><br></pre></td></tr></table></figure>

<p>const对象一旦创建后，任何试图为bufSize赋值的行为都将引发错误。所以const对象必须初始化。初始值可以是任意复杂的表达式。</p>
<blockquote>
<p>const学的非常不好…可以回头再多看看</p>
</blockquote>
<h2 id="26-const的引用"><a href="#26-const的引用" class="headerlink" title="26.const的引用"></a>26.const的引用</h2><p>与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const int ci = 1024;</span><br><span class="line">const int &amp;r1 = ci;</span><br><span class="line"></span><br><span class="line">r1 = 42;  //错误，r1是对常量的引用</span><br><span class="line">const int &amp;r = r1;  //合法，但是不允许通过r修改r1</span><br><span class="line">int &amp;r2 = ci;  //错误，试图让一个非常量引用指向一个常量对象==&gt;尤其容易搞错</span><br></pre></td></tr></table></figure>

<p>假设第四句是合法的，则可以通过r2来改变它引用对象的值，这显然不正确。</p>
<h2 id="27-指针和const"><a href="#27-指针和const" class="headerlink" title="27.指针和const"></a>27.指针和const</h2><p>指针的类型必须与其所指对象的类型一致，但有两个意外。<br>1.允许一个指向常量的指针指向一个非常量对象。<br>2.</p>
<p>引用的类型必须与其所引用对象的类型一致，但有两个例外。<br>1.在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。<br>2.</p>
<h2 id="28-非常量引用不能引用字面值常量"><a href="#28-非常量引用不能引用字面值常量" class="headerlink" title="28.非常量引用不能引用字面值常量"></a>28.非常量引用不能引用字面值常量</h2><h2 id="29-顶层-amp-amp-底层"><a href="#29-顶层-amp-amp-底层" class="headerlink" title="29.顶层 &amp;&amp; 底层"></a>29.顶层 &amp;&amp; 底层</h2><p>顶层const：表示指针本身是一个常量。可以表示任意的对象是常量，对任何数据类型都适用。<br>底层const：表示指针所指的对象是一个常量。与指针和引用等复合类型的基本类型部分有关。</p>
<h2 id="30-constexpr和常量表达式"><a href="#30-constexpr和常量表达式" class="headerlink" title="30.constexpr和常量表达式"></a>30.constexpr和常量表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int max_files = 20;    //是常量表达式</span><br><span class="line">const int limit = max_files + 1;    //是</span><br><span class="line">int staff_size = 27;    //不是</span><br><span class="line">const int sz = get_size();    //不是</span><br></pre></td></tr></table></figure>

<p>其中staff_size的初始值是一个字面值常量，但是它只是一个普通的int，而非const int，所以不属于常量表达式。<br>sz本身是一个常量，但是它的具体值直到运行时才能获取到，所以不是常量表达式。<br>C++11规定，允许将变量声明为<strong>constexpr</strong>类型以便由编译器来验证变量的值是否是一个常量表达式。尽管不能使用普通的函数作为constexpr变量的初始值，但允许用constexpr函数（足够简单以使得编译时就可以计算其结果）去初始化constexpr变量。<br>而声明constexpr时用到的类型称为“字面值类型”<br>一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p>
<h2 id="31-定义类型别名"><a href="#31-定义类型别名" class="headerlink" title="31.定义类型别名"></a>31.定义类型别名</h2><p>1.使用关键字<strong>typedef</strong><br>2.使用别名声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using SI = Sales_item;    //SI是Sales_item的同义词</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>9.14更（今天又出去玩了…）<blockquote>
<p>p61需要再研究</p>
</blockquote>
</li>
</ul>
<h2 id="32-auto类型说明符"><a href="#32-auto类型说明符" class="headerlink" title="32.auto类型说明符"></a>32.auto类型说明符</h2><p>能让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。所以，auto定义的变量必须有初始值。<br>如果使用auto在一条语句中声明多个变量，则要保证该语句中所有变量的初始基本数据类型都一样。</p>
<h2 id="33-decltype类型指示符"><a href="#33-decltype类型指示符" class="headerlink" title="33.decltype类型指示符"></a>33.decltype类型指示符</h2><p>作用：选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。<br>eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(f()) sum = x;  //sum的类型就是函数f()的返回类型</span><br></pre></td></tr></table></figure>

<p>如果decltype使用的表达式是一个变量，则返回该变量的类型（包括顶层const和引用在内）。<br>如果decltype使用的变量加上了一层或多层括号，编译器就会把他当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型。<br>eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decltype((i)) d;  //错误，d是int&amp;，必须初始化</span><br><span class="line">decltype (i) d;  //正确，d是int</span><br></pre></td></tr></table></figure>

<blockquote>
<p>decltype((variable))的结果永远是引用，而decltype(variable)的结果只有当var本身是引用时才是引用。</p>
</blockquote>
<hr>
<ul>
<li>9.25更</li>
</ul>
<p>从第五空间线下回来了…好菜…又刷了点pwn题，继续哈~</p>
<h2 id="34-预处理器"><a href="#34-预处理器" class="headerlink" title="34.预处理器"></a>34.预处理器</h2><p>从c语言继承而来，确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong><br>预处理功能<br>1.<strong>#include</strong>：用指定的头文件的内容代替#include<br>2.<strong>头文件保护符</strong>：依赖于预处理变量。<strong>#define</strong>把一个名字设定为预处理变量，<strong>#ifdef</strong>当且仅当变量已定义时为真，<strong>#ifndef</strong>当且仅当变量未定义时为真。一旦检查为真，则执行后续操作直至遇到<strong>#endif</strong>为止。</p>
<blockquote>
<p>程序员一般习惯性的加上头文件保护符，不太在乎程序是否需要</p>
</blockquote>
<h2 id="35-抽象数据类型库"><a href="#35-抽象数据类型库" class="headerlink" title="35.抽象数据类型库"></a>35.抽象数据类型库</h2><p>string和vector是两种最重要的标准库类型，前者支持可变长字符串，后者表示可变长的集合。还有一种标准库类型是迭代器，它是string和vector的配套类型，常被用于访问string中的字符或vector中的元素。</p>
<h2 id="36-using"><a href="#36-using" class="headerlink" title="36.using"></a>36.using</h2><p>我们用到的库函数基本都属于命名空间std，同时使用作用域操作符（::）<br>简单途径就是 使用<strong>using声明</strong>使用到命名空间的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace::name;</span><br></pre></td></tr></table></figure>

<p>用到的每个名字都必须有自己的声明语句，分号结束。</p>
<p>头文件不应包含using声明</p>
<h2 id="37-include"><a href="#37-include" class="headerlink" title="37.#include"></a>37.#include<string></string></h2><p>可以定义很多种<strong>初始化string对象</strong>的方法=.=【使用等号（=）执行<strong>拷贝初始化</strong>，否则为<strong>直接初始化</strong>】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1;    //默认初始化，s1是一个空字符串</span><br><span class="line">string s2(s1);    //s2是s1的副本</span><br><span class="line">string s2 = s1;    //等价于s2(s1)</span><br><span class="line">string s3(&quot;value&quot;);    //s3是字面值“value”的副本，除了字面值最后的那个空字符串</span><br><span class="line">string s3 = &quot;value&quot;;    //等价于s3(&quot;value&quot;)，s3是字面值“value”的副本</span><br><span class="line">string s4(n, &apos;c&apos;);    //把s4初始化为由连续n个字符c组成的串</span><br></pre></td></tr></table></figure>

<p><strong>string对象上的操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os&lt;&lt;s;    //将s写到输出流os当中，返回os</span><br><span class="line">is&gt;&gt;s;    //从is中读取字符串赋给s，字符串以空白分隔，返回is</span><br><span class="line">getline(is, s);    //从is中读取一行赋给s，返回is</span><br><span class="line">s.empty();    //s为空返回true，否则返回false</span><br><span class="line">s.size();    //返回s中字符的个数</span><br></pre></td></tr></table></figure>

<p>string对象会自动忽略开头的空白（即空格符、换行符、制表符等），并从第一个真正的字符开始读起，直到遇见下一处空白为止。</p>
<hr>
<ul>
<li>9.26更<h2 id="38-getline"><a href="#38-getline" class="headerlink" title="38.getline"></a>38.getline</h2></li>
</ul>
<p><strong>getline</strong>函数从给定输入流中读入内容，直到遇到换行符为止（<strong>换行符也被读进来了</strong>），如果输入的一开始就是换行符，那么所得的结果是个空string。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line">//每次读入一整行，直至到达文件末尾</span><br><span class="line">while(getline(cin, line))</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>empty函数</strong>：根据string对象是否为空返回一个对应的布尔值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//每次读入一行，遇到空行直接跳过</span><br><span class="line">while(getline(cin, line))</span><br><span class="line">     if(!line.empty())</span><br><span class="line">          cout &lt;&lt; line &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>size函数</strong>：返回string对象的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(getline(cin, line))</span><br><span class="line">     if(line.size() &gt; 80)</span><br><span class="line">          cout &lt;&lt; line &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>size函数返回的是一个<strong>string::size_type</strong>类型。它是一个无符号类型的值而且能够存放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string::size_type类型。</p>
<p>C++11新标准中，允许编译器通过auto或者decltype来推断变量的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto len = line. size();    //len的类型是string::size_type</span><br></pre></td></tr></table></figure>

<p>假设n是一个负值int，则表达式s. size() &lt; n的判断结果几乎肯定是true。这是因为负值n会自动地转换成一个比较大的无符号值。</p>
<p>tips：如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。</p>
<p><strong>string对象的比较</strong>依照字典顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = &quot;hello&quot;;     //3</span><br><span class="line">string phrase = &quot;hello world&quot;;     //2</span><br><span class="line">string slang = &quot;hiya&quot;;     //1</span><br></pre></td></tr></table></figure>

<p><strong>两个string对象相加</strong>使用（+）（+=）直接串接而成。</p>
<p><strong>字面值和string对象相加</strong>：必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strjng s1 = &quot;hello&quot;;</span><br><span class="line">string s = s1 + &quot;,&quot; + &quot; world&quot;;</span><br><span class="line">//正确</span><br></pre></td></tr></table></figure>

<h2 id="39-处理string中的字符"><a href="#39-处理string中的字符" class="headerlink" title="39.处理string中的字符"></a>39.处理string中的字符</h2><p><strong>cctype头文件中的函数</strong>：过多… 用到时查一下，记住常用的好了。</p>
<p><strong>使用c++版本的c标准库头文件</strong>：c语言头文件形如<em>name.h</em>，c++将这些文件命名为<em>cname</em>，c表示这是一个属于c语言的头文件。</p>
<h2 id="40-范围for语句"><a href="#40-范围for语句" class="headerlink" title="40.范围for语句"></a>40.范围for语句</h2><p>for(<em>declaration</em> : <em>expression</em>)<br>&#160;&#160;&#160;&#160;&#160;&#160;  <em>statement</em></p>
<p>其中，<em>expression</em>部分是一个对象，用于表示一个序列。<em>declaration</em>部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，<em>declaration</em>部分的变量会<strong>被初始化为expression部分的下一个元素值</strong>。</p>
<p>访问string对象中的单个字符有两种方式，一种是使用下标运算符（<strong>[ ]</strong>），另一种是使用迭代器。<br>注意下标的设置，因为c++标准并不要求标准库检测下标是否合法。</p>
<hr>
<ul>
<li>9.28更</li>
</ul>
<h2 id="41-标准库类型vector"><a href="#41-标准库类型vector" class="headerlink" title="41.标准库类型vector"></a>41.标准库类型vector</h2><p><strong>vector</strong>表示对象的集合，其中所有对象的类型都相同。它也常被称为<strong>容器</strong>。<br>要使用vector必须包含适当的头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;vector&gt;</span><br><span class="line">using std::vector;</span><br></pre></td></tr></table></figure>

<p>C++语言既有类模板，也有函数模板。其中vector是一个类模板。编译器根据模板创建类或函数的过程称为<strong>实例化</strong>，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec;    //ivec保存int类型的对象</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; files;    //该向量的元素是vector对象</span><br></pre></td></tr></table></figure>

<p>vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。<br>早期版本C++标准：vector&lt;vector<int> &gt; //======&gt;外层添加一个空格<br>C++11标准：vector&lt;vector<int>&gt;<br><strong>初始化vector对象的方法</strong><br>|||<br>-|-|<br>vector<t> v1| v1是一个空vector，它潜在的元素是T类型的，执行默认初始化|<br>vector<t> v2(v1) | v2中包含v1所有元素的副本 |<br>vector<t> v2 = v1 | 等价于上一条 |<br>vector<t> v3(n, val) | v3包含了n个重复的元素，每个元素的值都是val |<br>vector<t> v4(n) | v4包含了n个重复地执行了<strong>值初始化的</strong>对象|<br>vector<t> v5{a, b, c … } | v5包含了初始值个数的元素，每个元素被赋予相应的初始值|<br>vector<t> v5 = {a, b, c … } | 等价于上一条—&gt;<strong>列表初始化</strong>|<br>可以选择初始化为空，或者进行拷贝。 如果vector对象中的元素的类型不支持默认初始化，我们就必须提供初始化的元素值。</t></t></t></t></t></t></t></int></int></p>
<p>可以通过花括号（<strong>{ }</strong>）和圆括号（<strong>( )</strong>）来区别是列表初始化还是元素数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v1(10);    //v1有10个元素，每个元素的值都是0</span><br><span class="line">vector&lt;int&gt; v2&#123;10&#125;;    //v2有1个元素，值为10</span><br><span class="line">vector&lt;int&gt; v3(10, 1);    //v3有10个元素，每个的值都是1</span><br><span class="line">vector&lt;int&gt; v4&#123;10, 1&#125;;    //v4有两个元素，值分别是10和1</span><br></pre></td></tr></table></figure>

<p>但如果初始化时<strong>使用了花括号的形式</strong>但是提供的值又<strong>不能用来列表初始化</strong>，就要考虑用这样的值来构造vector对象了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v5(&quot;hi&quot;);    //列表初始化，v5有一个元素</span><br><span class="line">vector&lt;string&gt; v6&#123;&quot;hi&quot;&#125;;    //错误：不能使用字符串字面值构建vector对象</span><br><span class="line">vector&lt;string&gt; v7&#123;10&#125;;    //v7有10个默认初始化的元素</span><br><span class="line">vector&lt;string&gt; v8&#123;10， ”hi“&#125;;    //v8有10个值为“hi”的元素</span><br></pre></td></tr></table></figure>

<p><strong>vector的成员函数push_back</strong>：负责把一个值当成vector对象的尾元素“压到（push）”vector对象的“尾端（back）”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string word;</span><br><span class="line">vector&lt;string&gt; text;</span><br><span class="line">while(cin &gt;&gt; word)&#123;</span><br><span class="line">  text.push_back(word);    //将word添加到text后面</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>范围for语句体内不应改变其所遍历序列的大小。</p>
</blockquote>
<p>除了push_back外，vector还提供了几种其他操作，大多与string类似。</p>
<blockquote>
<p>vector对象及string对象的下标运算可用于访问已存在的元素，而不能用于添加元素。对于vector对象，正确的方法是使用push_back。</p>
</blockquote>
<p>关于下标必须明确的一点是：只能对确知已存在的元素执行下标操作。</p>
<hr>
<ul>
<li>9.30更<h2 id="42-迭代器"><a href="#42-迭代器" class="headerlink" title="42.迭代器"></a>42.迭代器</h2>有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。</li>
</ul>
<p>和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。这些类型都拥有名为<strong>begin</strong>和<strong>end</strong>的成员。<br>如果对象是常量，begin和end返回const_iterator，否则，返回interator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v;</span><br><span class="line">const vector&lt;int&gt; cv;</span><br><span class="line">auto it1 = v.begin();		//it1类型是vector&lt;int&gt;::iterator</span><br><span class="line">auto it2 = cv.begin();		//it2类型是vector&lt;int&gt;::const_iterator</span><br></pre></td></tr></table></figure>

<p>C++11新引入了cbegin，cend，为了确保不管怎样返回类型都为const_iterator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//b表示v的第一个元素，e表示v尾元素的下一位置</span><br><span class="line">auto b = v. begin(),  e = v.end();</span><br><span class="line">auto it = v.cbegin();		//it的类型是vector&lt;int&gt;::const_iterator</span><br></pre></td></tr></table></figure>

<p>尾后迭代器（尾迭代器）没有什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素，不能对其进行递增或解引用的操作。<br>如果容器为空，则begin和end返回的是<strong>同一个迭代器</strong>，都是尾后迭代器。<br><strong>标准容器迭代器的运算符</strong>与C类似，见到就能懂是干嘛的。</p>
<blockquote>
<p>C++程序员习惯性使用!=或==，是因为所有标准库容器都定义了他们，而大多数没有定义&lt;运算符。</p>
</blockquote>
<hr>
<ul>
<li>11.24更，我好能鸽</li>
</ul>
<p>迭代器精确类型无须知道。<br><code>const_iterator</code>能读取但是不能修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*it).empty() 相当于 it-&gt;empty()		//解引用it，然后调用结果对象的empty成员，检查it所指字符串是否为空</span><br></pre></td></tr></table></figure>

<p>试图在循环体中对迭代器所属容器添加元素，或任何一种可能改变vector对象容量的操作，如<code>push_back</code>，都会使迭代器失效<br>迭代器运算：主要是位置关系的运算，不是简单的在自身上加减 </p>
<blockquote>
<p>关于<strong>指针</strong>和<strong>迭代器</strong><br>这里引用<a href="https://www.zhihu.com/question/54047747/answer/137755282" target="_blank" rel="noopener">Alinshans在知乎上的回答</a><br>如果只讨论 STL container 类的 iterator，它们其实都是一种泛型指针。C风格指针是属于 iterator 的一种的。iterator 根据功能做了更细的划分，STL 中的 iterator 分成了五类。我觉得它们的区别：<br>1.在范围上，pointer 属于 iterator 的一种（random access iterator）<br>2.在功能上，iterator 有着比 pointer 更细的划分并对应能力不同的功能（重载不同的运算符）<br>3.在行为上，iterator 比 pointer 更统一和良好的用法（更轻易使用 begin()、end()且不用担心越界）等<br><strong>我觉得</strong>：额…但是似乎并不是这么简单的涵盖问题，迭代器贴近一层抽象，进行封装。数组，链表十分不利于代码重用<br><a href="https://www.zhihu.com/question/54047747/answer/137783330" target="_blank" rel="noopener">另外一位答者Khellendros的回答我觉得很好</a><br>迭代器实际上是对“遍历容器”这一操作进行了封装。在编程中我们往往会用到各种各样的容器，但由于这些容器的底层实现各不相同，所以对他们进行遍历的方法也是不同的。例如，数组使用指针算数就可以遍历，但链表就要在不同节点直接进行跳转。这是非常不利于代码重用的。例如你有一个简单的查找容器中最小值的函数findMin，如果没有迭代器，那么你就必须定义适用于数组版本的findMin和适用于链表版本的findMin，如果以后有更多容器需要使用findMin，那就只好继续添加重载……而如果每个容器又需要更多的函数例如findMax，sort，那简直就是重载地狱……我们的救星就是迭代器啦！如果我们将这些遍历容器的操作都封装成迭代器，那么诸如findMin一类的算法就都可以针对迭代器编程而不是针对具体容器编程，工作量一下子就少了很多！至于指针，由于指针也可以用来遍历容器(数组)，所以指针也可是算是迭代器的一种。但是指针还有其他功能，并不只局限于遍历数组。因为使用指针变量数组的操作太深入人心，c++stl中的迭代器就是刻意仿照指针来设计接口的</p>
</blockquote>
<ul>
<li>11.27<h2 id="43-数组"><a href="#43-数组" class="headerlink" title="43.数组"></a>43.数组</h2>与vector相似，数组的元素应为<strong>对象</strong>，不存在引用的数组。但数组的大小固定，对某些特殊的应用来说程序的运行时性能较好，但是灵活性差。<br>定义数组不允许用auto关键字。</li>
<li>字符数组特殊性【这点同C语言】<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char a1[] = &#123;&apos;C&apos;, &apos;+&apos;, &apos;+&apos;&#125;;</span><br><span class="line">char a2[] = &#123;&apos;C&apos;, &apos;+&apos;, &apos;+&apos;, &apos;\0&apos;&#125;;</span><br><span class="line">char a3[] = &quot;C++&quot;;</span><br><span class="line">char a4[6] = &quot;Daniel&quot;;		//错误，因为使用符串字面值初始化会自动添加空字符\0</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>为了更加明显的理解【遗憾的是，c和c++并没有定义直接返回数组长度的函数】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	char a1[] = &#123; &apos;C&apos;, &apos;+&apos;, &apos;+&apos; &#125;;</span><br><span class="line">	char a2[] = &#123; &apos;C&apos;, &apos;+&apos;, &apos;+&apos;, &apos;\0&apos; &#125;;</span><br><span class="line">	char a3[] = &quot;C++&quot;;</span><br><span class="line">	char a4[6] = &quot;Danil&quot;;</span><br><span class="line">	cout &lt;&lt; &quot;a1长度为：&quot; &lt;&lt; sizeof(a1) / sizeof(a1[0]) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">	cout &lt;&lt; &quot;a2长度为：&quot; &lt;&lt; sizeof(a2) / sizeof(a2[0]) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">	cout &lt;&lt; &quot;a3长度为：&quot; &lt;&lt; sizeof(a3) / sizeof(a3[0]) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">	cout &lt;&lt; &quot;a4长度为：&quot; &lt;&lt; sizeof(a4) / sizeof(a4[0]) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a1长度为：3</span><br><span class="line">a2长度为：4</span><br><span class="line">a3长度为：4</span><br><span class="line">a4长度为：6</span><br></pre></td></tr></table></figure>

<p>数组不允许直接拷贝和赋值。【一些编译器支持，这就是<strong>编译器扩展</strong>，但是可移植性不强…】<br>理解数组声明的意义，最好从数组的名字开始按照由内到外顺序阅读。</p>
<p>数组下标定义为<code>size_t</code>类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int a[] = &#123; 0, 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">	int* pa = a;</span><br><span class="line">	int* pa2 = &amp;a[0];</span><br><span class="line"></span><br><span class="line">	auto pa3(a);		//整型指针，指向a的第一个元素</span><br><span class="line">	//pa3 = 12;		//pa3是整型指针，不能用int赋值。</span><br><span class="line"></span><br><span class="line">	decltype(a) a_ = &#123; 1, 3, 5, 7, 9 &#125;;</span><br><span class="line"></span><br><span class="line">	string b[] = &#123; &quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot; &#125;;</span><br><span class="line">	//int* pb = b;	//报错</span><br><span class="line">	string* pb2 = b;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;pa = &quot; &lt;&lt; pa &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;pa2 = &quot; &lt;&lt; pa2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;pa3 = &quot; &lt;&lt; pa3 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;a_ = &quot; &lt;&lt; a_ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;pb2 = &quot; &lt;&lt; pb2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pa = 004FFC88</span><br><span class="line">pa2 = 004FFC88</span><br><span class="line">pa3 = 004FFC88</span><br><span class="line">a_ = 004FFC44</span><br><span class="line">pb2 = 004FFBE8</span><br></pre></td></tr></table></figure>

<p>vector string的迭代器支持的运算，数组的指针全部支持。<br>数组头地址的获取上面有示例，数组尾么有接触过，是这么得到尾元素后那个并不存在的元素的地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *e = &amp;arr[10];</span><br></pre></td></tr></table></figure>

<p>不能对尾后指针执行解引用或递增的操作。</p>
<p>okok更安全简单的获取指针的方法来啦。<strong>begin</strong> &amp; <strong>end</strong>，这两个函数是不是看起来很熟悉？他们在<em>容器</em>中也出现了。<br>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;0, 1, 2, 3, 4, 5&#125;;</span><br><span class="line">int *beg = begin(a);</span><br><span class="line">int *last = end(a);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto n = end(arr) - begin(arr);</span><br><span class="line">//结果类型为ptrdiff_t</span><br></pre></td></tr></table></figure>

<ul>
<li>11.28</li>
</ul>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>指针的类型必须与指向的地址的变量的类型一致。</p>
<p>指针用箭头<code>-&gt;</code>来指；<br>解引用后用<code>.</code>来指。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stu *pStu = &amp;Stu1;</span><br><span class="line">(*pStu).name = &quot;Wang&quot;;</span><br><span class="line">pStu-&gt;name = &quot;Kun&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="函数的重载和覆盖"><a href="#函数的重载和覆盖" class="headerlink" title="函数的重载和覆盖"></a>函数的重载和覆盖</h2><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul>
<li>提取子字符串</li>
<li>比较字符串</li>
<li>添加字符串</li>
<li>搜索字符串</li>
</ul>
<hr>
<blockquote>
<p>最近被boss限制了代码风格，要求用对应大括号而不是尾后括号，所以改一下风格…</p>
</blockquote>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>可以在声明某个类的同时立刻创建一些该类的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Car</span><br><span class="line">&#123;</span><br><span class="line">	···</span><br><span class="line">&#125;car1, car2;</span><br></pre></td></tr></table></figure>

<p><strong>但是！！！应该避免这种做法</strong></p>
<h2 id="构造器与析构器"><a href="#构造器与析构器" class="headerlink" title="构造器与析构器"></a>构造器与析构器</h2><ul>
<li>构造器名称必须与它所在的类的名字一样</li>
<li>系统在创建某个类的实例时，会第一时间自动调用这个类的构造器</li>
<li>构造器永远不会返回任何值</li>
<li>构造器不写也会自动生成</li>
<li>析构器不带参数，也不会返回任何值<br>一般来说，构造器用来完成事先初始化和准备工作（申请分配内存）<br>析构器用来完成事后所必须的清理工作（清理内存）【java会自动清理，c++没有】</li>
</ul>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Hello</span><br><span class="line">&#123;</span><br><span class="line">	Hello(void);	//构造器</span><br><span class="line">	~Hello();		//析构器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>解决二义性隐患</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>基类（父类、超类）</li>
<li>子类</li>
</ul>
<p>继承机制中的构造器与析构器稍复杂</p>
<h2 id="关于endl和’-n’的区别"><a href="#关于endl和’-n’的区别" class="headerlink" title="关于endl和’\n’的区别"></a>关于endl和’\n’的区别</h2><p><a href="https://blog.csdn.net/u011675745/article/details/51939094" target="_blank" rel="noopener">https://blog.csdn.net/u011675745/article/details/51939094</a></p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ul>
<li>public    ==&gt;允许任何代码访问</li>
<li>protected        ==&gt;只有这个类本身和它的子类可以访问</li>
<li>private        ==&gt;只有这个类本身可以访问</li>
</ul>
<h2 id="和java有点像喔…"><a href="#和java有点像喔…" class="headerlink" title="和java有点像喔…"></a>和java有点像喔…</h2><p>跟着上面的练习更…</p>
<h1 id="一些easy-test"><a href="#一些easy-test" class="headerlink" title="一些easy_test"></a>一些easy_test</h1><h2 id="读取文本"><a href="#读取文本" class="headerlink" title="读取文本"></a>读取文本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	ifstream in;	//文件**输入流**的类</span><br><span class="line">	in.open(&quot;C:\\Users\\jy\\Desktop\\flag.txt&quot;);</span><br><span class="line">	//这两句可替换为：ifstream in(&quot;C:\\Users\\jy\\Desktop\\flag.txt&quot;);</span><br><span class="line">	if (!in) &#123;</span><br><span class="line">		cerr &lt;&lt; &quot;打开文件夹失败！&quot; &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	char x;</span><br><span class="line">	while (in &gt;&gt; x) &#123;	//in每一次流一个字符到x</span><br><span class="line">		cout &lt;&lt; x;		//x再流到cout输出</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	in.close();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">//会出现中文乱码，空格和回车没有流</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/11/24/x4SgjiFKazNYLXo.png" alt="flag.txt中是带空格的，可是没有打印出来哦~"><br>ifstream 还可以接受不止一个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifstream in(char* filename, int open_mode)</span><br></pre></td></tr></table></figure>

<p>ios::in —— 打开一个可读取文件<br>ios::out —— 打开一个可写入文件<br>ios::binary —— 以二进制的形式打开一个文件<br>ios::app —— 写入的所有数据将被追加到文件的末尾【append】<br>ios::beg —— 使得文件指针指向文件头<br>ios::end —— 使得文件指针指向文件尾<br>ios::trunk —— 删除文件原来已存在的内容<br>ios::nocreate —— 如果要打开的文件不存在，那么以此参数调用open函数将无法进行<br>ios::noreplace —— 如果要打开的文件已存在，试图用open函数打开时将返回一个错误</p>
<p>可使用<code>|</code>来选择多种open_mode</p>
<h2 id="复制文本"><a href="#复制文本" class="headerlink" title="复制文本"></a>复制文本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">	char sourcename[80], destname[80], buffer[256];</span><br><span class="line">	int n;</span><br><span class="line">	cout &lt;&lt; &quot;请输入要复制的文件名：&quot; &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; sourcename;</span><br><span class="line">	cout &lt;&lt; &quot;请输入复制后的文件名：&quot; &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; destname;</span><br><span class="line">	ifstream in;</span><br><span class="line">	ofstream out;</span><br><span class="line">	in.open(sourcename, ios::in | ios::binary);</span><br><span class="line">	out.open(destname, ios::out | ios::binary);</span><br><span class="line">	if (!in |  !out) &#123;</span><br><span class="line">		cerr &lt;&lt; &quot;打开失败！&quot;;</span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	out &lt;&lt; in.rdbuf();</span><br><span class="line">	out.close();</span><br><span class="line">	in.close();</span><br><span class="line">	cout &lt;&lt; &quot;复制完毕！&quot; &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/11/25/Bs4dRg1XQOahGNw.png" alt="copyfile.png"></p>
<p>第二种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">	if (argc != 3) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;输入形式： copyfile 源文件名 目标文件名&quot; &lt;&lt; endl;</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	ifstream in;</span><br><span class="line">	ofstream out;</span><br><span class="line">	in.open(argv[1], ios::in|ios::binary);</span><br><span class="line">	out.open(argv[2], ios::out|ios::binary);</span><br><span class="line">	if (!in | !out) &#123;</span><br><span class="line">		cerr &lt;&lt; &quot;打开失败！&quot;;</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	out &lt;&lt; in.rdbuf();</span><br><span class="line">	out.close();</span><br><span class="line">	in.close();</span><br><span class="line">	cout &lt;&lt; &quot;复制成功！&quot; &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/11/25/6X1NBov4LlkmCqx.png" alt></p>
<p>argc 加上本身一共传入的参数个数。CVE20190841终端运行<br>输入格式 提示<br>argv[] 每个指针指向命令行的一个字符串</p>
<h2 id="字符串变大写！"><a href="#字符串变大写！" class="headerlink" title="字符串变大写！"></a>字符串变大写！</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	string s = &quot;some thing&quot;;</span><br><span class="line">	for (auto i = s.begin(); i != s.end() /*&amp;&amp; !isspace(*i)*/; i++)&#123;</span><br><span class="line">		* i = toupper(*i);</span><br><span class="line">		cout &lt;&lt; *i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOME THING</span><br></pre></td></tr></table></figure>

<h2 id="迭代器运算小🌰子"><a href="#迭代器运算小🌰子" class="headerlink" title="迭代器运算小🌰子"></a>迭代器运算小🌰子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	string str1 = &quot;abcdefg&quot;;</span><br><span class="line">	string str2 = &quot;123456789&quot;;</span><br><span class="line"></span><br><span class="line">	auto mid = str1.begin() + str1.size() / 2;</span><br><span class="line">	cout &lt;&lt; &quot;mid = &quot; &lt;&lt; *mid &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	auto x = str1.begin();</span><br><span class="line">	x += 2;		//我想直接使用 str1.begin() += 2 ，失败。因为str1.begin()是指针啊....【感谢delort】</span><br><span class="line">	cout &lt;&lt; &quot;str1_begin = &quot; &lt;&lt; *x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	auto n = str2.begin() - str2.end();		//返回类型difference_type</span><br><span class="line">	cout &lt;&lt; &quot;str2头到尾距离 = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mid = d</span><br><span class="line">str1_begin = c</span><br><span class="line">str2头到尾距离 = -9</span><br></pre></td></tr></table></figure>

<p>//使用迭代器实现二分查找法也是不错的</p>
<h2 id="构造器和析构器"><a href="#构造器和析构器" class="headerlink" title="构造器和析构器"></a>构造器和析构器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">class StoreFlag</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	std::string flag, speaker;</span><br><span class="line">	std::ofstream fileOutput;</span><br><span class="line"></span><br><span class="line">	StoreFlag();</span><br><span class="line">	~StoreFlag();</span><br><span class="line"></span><br><span class="line">	void inputFlag();</span><br><span class="line">	void inputSpeaker();</span><br><span class="line">	bool write();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StoreFlag::StoreFlag()</span><br><span class="line">&#123;</span><br><span class="line">	fileOutput.open(&quot;flag.txt&quot;, std::ios::app);		//append追加的形式打开，如果目录下没有flag.txt就新建</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StoreFlag::~StoreFlag()</span><br><span class="line">&#123;</span><br><span class="line">	fileOutput.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void StoreFlag::inputFlag()</span><br><span class="line">&#123;</span><br><span class="line">	std::getline(std::cin, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void StoreFlag::inputSpeaker()</span><br><span class="line">&#123;</span><br><span class="line">	std::getline(std::cin, speaker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool StoreFlag::write()</span><br><span class="line">&#123;</span><br><span class="line">	if (fileOutput.is_open())</span><br><span class="line">	&#123;</span><br><span class="line">		fileOutput &lt;&lt; flag &lt;&lt; &quot;——&quot; &lt;&lt; speaker &lt;&lt; &quot;\n&quot;;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	StoreFlag flag;</span><br><span class="line">	std::cout &lt;&lt; &quot;请输入flag：\n&quot;;</span><br><span class="line">	flag.inputFlag();</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; &quot;请输入队伍名：\n&quot;;</span><br><span class="line">	flag.inputSpeaker();</span><br><span class="line"></span><br><span class="line">	if (flag.write())</span><br><span class="line">		std::cout &lt;&lt; &quot;写入成功！\n&quot;;</span><br><span class="line">	else</span><br><span class="line">		std::cout &lt;&lt; &quot;写入失败！\n&quot;;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/12/20/nIGr8XzN47U1vMg.png" alt><br><img src="https://i.loli.net/2019/12/20/dZbrz7DYC2vywJ3.png" alt><br><img src="https://i.loli.net/2019/12/20/jcWxpuADq3VtSEb.png" alt></p>
<h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	std::string mouth;</span><br><span class="line"></span><br><span class="line">	void eat();</span><br><span class="line">	void sleep();</span><br><span class="line">	void drool();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Pig : public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void climb();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Turtle : public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void swim();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Animal::eat()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;I am eating!&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Animal::sleep()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;I am sleeping!&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Animal::drool()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;I am drooling!&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Pig::climb()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;A pig can climb&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Turtle::swim()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;A turtle can swim~&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Pig pig;</span><br><span class="line">	Turtle turtle;</span><br><span class="line">	pig.eat();</span><br><span class="line">	pig.climb();</span><br><span class="line">	turtle.sleep();</span><br><span class="line">	turtle.swim();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/12/20/1rvbKlZmNpDwxyY.png" alt="继承.png"></p>
<blockquote>
<p>参考：<a href="https://www.bilibili.com/video/av7595819" target="_blank" rel="noopener">小甲鱼c++入门学习视频</a></p>
</blockquote>
  
	  </div>
		  <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/笔记/">笔记</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/笔记/">笔记</a><a href="/tags/C/">C++</a>
  </div>

</div>



</footer>

   	       
	  </article>
	  
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/12/03/Tcache Attack学习/tcache/" title="Tcache Attack学习">
  <span>
  Tcache Attack学习</span>
</a>
</div>


<div class="next">
<a href="/2019/11/17/house of_系列学习之 house of orange/house of_系列学习/"  title="house of_系列学习之 house of orange">
 <span>house of_系列学习之 house of orange
</span>
</a>
</div>

</nav>

	  

</div> 
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		<a href="http://weibo.com/https://weibo.com/u/5213203661?refer_flag=0000015010_&amp;from=feed&amp;loc=nickname" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/p1Kk" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:p1kk_wang@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/ACM/" title="ACM">ACM<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/CTF/" title="CTF">CTF<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/oj/" title="oj">oj<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/笔记/" title="笔记">笔记<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/面经/" title="面经">面经<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/pwn/" title="pwn">pwn<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/笔记/" title="笔记">笔记<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/wp/" title="wp">wp<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/堆/" title="堆">堆<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/iot/" title="iot">iot<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/栈溢出/" title="栈溢出">栈溢出<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/栈/" title="栈">栈<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/环境搭建/" title="环境搭建">环境搭建<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/攻防世界/" title="攻防世界">攻防世界<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/AWD/" title="AWD">AWD<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/面经/" title="面经">面经<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/canary/" title="canary">canary<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/IO/" title="IO">IO<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ubuntu18/" title="ubuntu18">ubuntu18<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/HDU/" title="HDU">HDU<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C++">C++<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://whali3n51.github.io" target="_blank" title="whali3n51">whali3n51</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	

	<p class="copyright">
	Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2020 
	
	<a href="/about" target="_blank" title="p1Kk">p1Kk</a>
	
	
	</p>
</div></footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
