
 <!DOCTYPE HTML>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  
    <title>C++ 学习笔记【长期更】 | p1Kk&#39;s World!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="p1Kk">
    

    
    <meta name="description" content="在有c语言基础下学习《C++ Primer》的新知    9.7更1using namespace std;    1. 在控制台窗口内编译程序假定main程序保存在文件prog1.cc中，用如下命令编译它： 1$ CC prog1.cc  其中，CC为编译器程序的名字，$是系统提示符。 2. 输入流1cin &amp;gt;&amp;gt; 变量名;  输出流123cout &amp;lt;&amp;lt; &amp;quot;字符">
<meta name="keywords" content="笔记,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 学习笔记【长期更】">
<meta property="og:url" content="p1Kk.github.io/2019/10/03/C++学习笔记/C++笔记/index.html">
<meta property="og:site_name" content="p1Kk&#39;s World!">
<meta property="og:description" content="在有c语言基础下学习《C++ Primer》的新知    9.7更1using namespace std;    1. 在控制台窗口内编译程序假定main程序保存在文件prog1.cc中，用如下命令编译它： 1$ CC prog1.cc  其中，CC为编译器程序的名字，$是系统提示符。 2. 输入流1cin &amp;gt;&amp;gt; 变量名;  输出流123cout &amp;lt;&amp;lt; &amp;quot;字符">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-10-03T02:33:59.314Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 学习笔记【长期更】">
<meta name="twitter:description" content="在有c语言基础下学习《C++ Primer》的新知    9.7更1using namespace std;    1. 在控制台窗口内编译程序假定main程序保存在文件prog1.cc中，用如下命令编译它： 1$ CC prog1.cc  其中，CC为编译器程序的名字，$是系统提示符。 2. 输入流1cin &amp;gt;&amp;gt; 变量名;  输出流123cout &amp;lt;&amp;lt; &amp;quot;字符">

    
    <link rel="alternative" href="atom.xml" title="p1Kk&#39;s World!" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/site.jpg">
    
    
    <link rel="apple-touch-icon" href="/img/head.png">
    <link rel="apple-touch-icon-precomposed" href="/img/head.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo2.jpg" alt="p1Kk&#39;s World!" title="p1Kk&#39;s World!"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="p1Kk&#39;s World!">p1Kk&#39;s World!</a></h1>
				<h2 class="blog-motto">艺无止境，功不唐捐。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
						<li><a href="/tags">Tags</a></li>
					
						<li><a href="/categories">Categories</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:p1Kk.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	
	  <article itemprop="articleBody"> 
		  <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/10/03/C++学习笔记/C++笔记/" title="C++ 学习笔记【长期更】" itemprop="url">C++ 学习笔记【长期更】</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="p1Kk" target="_blank" itemprop="author">p1Kk</a>
		
  <p class="article-time">
    <time datetime="2019-10-03T02:15:33.079Z" itemprop="datePublished"> Published 2019-10-03</time>
    
  </p>
</header>
	  <div class="article-content">
		  
		  <div id="toc" class="toc-article">
			  <strong class="toc-title">Contents</strong>
		  
			  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-在控制台窗口内编译程序"><span class="toc-number">1.</span> <span class="toc-text">1. 在控制台窗口内编译程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-输入流"><span class="toc-number">2.</span> <span class="toc-text">2. 输入流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出流"><span class="toc-number">3.</span> <span class="toc-text">输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-for循环和while循环的对比"><span class="toc-number">4.</span> <span class="toc-text">3.for循环和while循环的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-读取数据直到文件尾"><span class="toc-number">5.</span> <span class="toc-text">4.读取数据直到文件尾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-一旦选择了一种风格，就要坚持使用。"><span class="toc-number">6.</span> <span class="toc-text">5.一旦选择了一种风格，就要坚持使用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-能定义使用上像内置类型一样自然的类类型"><span class="toc-number">7.</span> <span class="toc-text">6.能定义使用上像内置类型一样自然的类类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#没搞明白呢？先打个❓"><span class="toc-number">8.</span> <span class="toc-text">没搞明白呢？先打个❓</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-使用-include-lt-gt-“”"><span class="toc-number">9.</span> <span class="toc-text">7.使用#include&lt;&gt; // “”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-使用文件重定向"><span class="toc-number">10.</span> <span class="toc-text">8.使用文件重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-算术类型-amp-amp-空类型"><span class="toc-number">11.</span> <span class="toc-text">9.算术类型 &amp;&amp; 空类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-运算"><span class="toc-number">12.</span> <span class="toc-text">10.运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-’-‘-amp-“-“"><span class="toc-number">13.</span> <span class="toc-text">11.’ ‘ &amp; “ “</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-面向对象程序设计的思想"><span class="toc-number">14.</span> <span class="toc-text">12.面向对象程序设计的思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-初始化和赋值"><span class="toc-number">15.</span> <span class="toc-text">13.初始化和赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-列表初始化"><span class="toc-number">16.</span> <span class="toc-text">14.列表初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-默认初始化"><span class="toc-number">17.</span> <span class="toc-text">15.默认初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-分离式编译"><span class="toc-number">18.</span> <span class="toc-text">16.分离式编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-标识符"><span class="toc-number">19.</span> <span class="toc-text">17.标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-嵌套的作用域"><span class="toc-number">20.</span> <span class="toc-text">18.嵌套的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-引用（-amp-d，d是声明的变量）"><span class="toc-number">21.</span> <span class="toc-text">19.引用（&amp;d，d是声明的变量）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-空指针"><span class="toc-number">22.</span> <span class="toc-text">20.空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-赋值永远改变的是等号左侧的对象"><span class="toc-number">23.</span> <span class="toc-text">21.赋值永远改变的是等号左侧的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-两指针比较"><span class="toc-number">24.</span> <span class="toc-text">22.两指针比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-void-指针"><span class="toc-number">25.</span> <span class="toc-text">23.void* 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-指向指针的引用"><span class="toc-number">26.</span> <span class="toc-text">24.指向指针的引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-const限定符"><span class="toc-number">27.</span> <span class="toc-text">25.const限定符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-const的引用"><span class="toc-number">28.</span> <span class="toc-text">26.const的引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-指针和const"><span class="toc-number">29.</span> <span class="toc-text">27.指针和const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-非常量引用不能引用字面值常量"><span class="toc-number">30.</span> <span class="toc-text">28.非常量引用不能引用字面值常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-顶层-amp-amp-底层"><span class="toc-number">31.</span> <span class="toc-text">29.顶层 &amp;&amp; 底层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-constexpr和常量表达式"><span class="toc-number">32.</span> <span class="toc-text">30.constexpr和常量表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-定义类型别名"><span class="toc-number">33.</span> <span class="toc-text">31.定义类型别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-auto类型说明符"><span class="toc-number">34.</span> <span class="toc-text">32.auto类型说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-decltype类型指示符"><span class="toc-number">35.</span> <span class="toc-text">33.decltype类型指示符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-预处理器"><span class="toc-number">36.</span> <span class="toc-text">34.预处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-抽象数据类型库"><span class="toc-number">37.</span> <span class="toc-text">35.抽象数据类型库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-using"><span class="toc-number">38.</span> <span class="toc-text">36.using</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-include"><span class="toc-number">39.</span> <span class="toc-text">37.#include</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-getline"><span class="toc-number">40.</span> <span class="toc-text">38.getline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-处理string中的字符"><span class="toc-number">41.</span> <span class="toc-text">39.处理string中的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-范围for语句"><span class="toc-number">42.</span> <span class="toc-text">40.范围for语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-标准库类型vector"><span class="toc-number">43.</span> <span class="toc-text">41.标准库类型vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-迭代器"><span class="toc-number">44.</span> <span class="toc-text">42.迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43"><span class="toc-number">45.</span> <span class="toc-text">43.</span></a></li></ol>
		  
		  </div>
		  
		  <blockquote>
<p>在有c语言基础下学习《C++ Primer》的新知</p>
</blockquote>
<hr>
<ul>
<li>9.7更<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1-在控制台窗口内编译程序"><a href="#1-在控制台窗口内编译程序" class="headerlink" title="1. 在控制台窗口内编译程序"></a>1. 在控制台窗口内编译程序</h2><p>假定main程序保存在文件prog1.cc中，用如下命令编译它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CC prog1.cc</span><br></pre></td></tr></table></figure>

<p>其中，CC为编译器程序的名字，$是系统提示符。</p>
<h2 id="2-输入流"><a href="#2-输入流" class="headerlink" title="2. 输入流"></a>2. 输入流</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; 变量名;</span><br></pre></td></tr></table></figure>

<h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;字符串字面常量&quot; &lt;&lt; 变量运算 &lt;&lt; endl;</span><br><span class="line">               |              |</span><br><span class="line">                    可有可无</span><br></pre></td></tr></table></figure>

<h2 id="3-for循环和while循环的对比"><a href="#3-for循环和while循环的对比" class="headerlink" title="3.for循环和while循环的对比"></a>3.for循环和while循环的对比</h2><p>在循环次数已知的情况下，for循环的形式更简洁。<br>循环次数无法预知时，用while循环实现更适合。<br>用特定条件控制循环是否执行，循环体中执行的语句可能导致循环判定条件发生变化。</p>
<h2 id="4-读取数据直到文件尾"><a href="#4-读取数据直到文件尾" class="headerlink" title="4.读取数据直到文件尾"></a>4.读取数据直到文件尾</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(cin &gt;&gt; value)</span><br></pre></td></tr></table></figure>

<p>直接对输入流cin进行检测<br><strong>其中键入时，windows系统中，输入文件结束符的方法是Ctrl+Z，然后按Enter或Return<br>在unix系统和Mac OS X系统中，文件结束符的输入是Ctrl+D</strong></p>
<h2 id="5-一旦选择了一种风格，就要坚持使用。"><a href="#5-一旦选择了一种风格，就要坚持使用。" class="headerlink" title="5.一旦选择了一种风格，就要坚持使用。"></a>5.一旦选择了一种风格，就要坚持使用。</h2><p>really？？？嘻嘻，觉得想换就可以改进嘛</p>
<h2 id="6-能定义使用上像内置类型一样自然的类类型"><a href="#6-能定义使用上像内置类型一样自然的类类型" class="headerlink" title="6.能定义使用上像内置类型一样自然的类类型"></a>6.能定义使用上像内置类型一样自然的类类型</h2><p>给的Sales_item.h头文件 网址==<a href="http://www.informit.com/store/c-plus-plus-primer-9780321714114" target="_blank" rel="noopener">http://www.informit.com/store/c-plus-plus-primer-9780321714114</a>，是卖书的。。。</p>
<h2 id="没搞明白呢？先打个❓"><a href="#没搞明白呢？先打个❓" class="headerlink" title="没搞明白呢？先打个❓"></a>没搞明白呢？先打个❓</h2><ul>
<li>9.8更</li>
</ul>
<h2 id="7-使用-include-lt-gt-“”"><a href="#7-使用-include-lt-gt-“”" class="headerlink" title="7.使用#include&lt;&gt; // “”"></a>7.使用#include&lt;&gt; // “”</h2><p>包含来自标准库的头文件时，应该用<code>&lt; &gt;</code>包围头文件名。对于不属于标准库的头文件，则使用<code>&quot; &quot;</code>包围<br>（在学习c语言的时候，没有太注意&lt;&gt;和””的区别）</p>
<h2 id="8-使用文件重定向"><a href="#8-使用文件重定向" class="headerlink" title="8.使用文件重定向"></a>8.使用文件重定向</h2><p>测试程序时，允许我们将标准输入和标准输出与命名文件关联起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ addItems &lt;infile &gt;outfile</span><br><span class="line">|     |        |       |</span><br><span class="line">|  可执行文件   |       |</span><br><span class="line">系统提示符     从infile中读取将输出结果写入outfile</span><br></pre></td></tr></table></figure>

<h2 id="9-算术类型-amp-amp-空类型"><a href="#9-算术类型-amp-amp-空类型" class="headerlink" title="9.算术类型 &amp;&amp; 空类型"></a>9.算术类型 &amp;&amp; 空类型</h2><p>算术类型分为两类：<strong>整型</strong>（包括<strong>字符</strong>和<strong>布尔类型</strong>在内）和<strong>浮点型</strong></p>
<h2 id="10-运算"><a href="#10-运算" class="headerlink" title="10.运算"></a>10.运算</h2><p>c语言没有注意过，但是这是个漏洞点哟<br>当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数<br>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned u = 10;</span><br><span class="line">	int i = -42;</span><br><span class="line">	cout &lt;&lt; i + i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; u + i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-84</span><br><span class="line">4294967264</span><br></pre></td></tr></table></figure>

<p>相加前先把整数-42转换成无符号数，</p>
<hr>
<ul>
<li>9.10更</li>
</ul>
<p>今天觉得自己c语言学的真粗糙，嘿嘿</p>
<h2 id="11-’-‘-amp-“-“"><a href="#11-’-‘-amp-“-“" class="headerlink" title="11.’ ‘ &amp; “ “"></a>11.’ ‘ &amp; “ “</h2><p>例如：字面值’A’表示的是单独的字母A，而字符串”A”则代表了一个字符的数组，该数组包含两个字符：一个是字母A，另一个是空字符（’\0’）</p>
<h2 id="12-面向对象程序设计的思想"><a href="#12-面向对象程序设计的思想" class="headerlink" title="12.面向对象程序设计的思想"></a>12.面向对象程序设计的思想</h2><p>通常情况下，<strong>对象</strong>是指一块能存储数据并具有某种类型的内存空间。<br>更加细致可以参考：<a href="https://blog.csdn.net/jerry11112/article/details/79027834" target="_blank" rel="noopener">面向对象与面向过程的本质的区别</a></p>
<h2 id="13-初始化和赋值"><a href="#13-初始化和赋值" class="headerlink" title="13.初始化和赋值"></a>13.初始化和赋值</h2><p>在C++语言中，初始化和赋值是两个完全不同的操作。然而在很多编程语言中二者的区别几乎可以忽略不计，即使在C++中有时这种区别也无关紧要，但是需要强调的是，这个概念至关重要，后面会经常提到。<br>初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p>
<h2 id="14-列表初始化"><a href="#14-列表初始化" class="headerlink" title="14.列表初始化"></a>14.列表初始化</h2><p>要想定义一个名为units_sold的int变量并初始化为0，可以使用一下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int units_sold = 0;</span><br><span class="line">int units_sold = &#123;0&#125;;</span><br><span class="line">int units_sold&#123;0&#125;;</span><br><span class="line">int units_sold(0);</span><br></pre></td></tr></table></figure>

<h2 id="15-默认初始化"><a href="#15-默认初始化" class="headerlink" title="15.默认初始化"></a>15.默认初始化</h2><p>如果内置类型的变量未被显式初始化，则：<br>1.定义于任何函数体之外的变量被初始化为0。<br>2.定义在函数体内部的内置类型变量将不被初始化，此时试图拷贝或以其他形式访问此类值将引发错误。<br>3.绝大多数类都支持无需显式初始化而定义对象，如string类规定如果没有指定处值则生成一个空串。<br>4.一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而没有明确初始化操作，则引发错误。</p>
<h2 id="16-分离式编译"><a href="#16-分离式编译" class="headerlink" title="16.分离式编译"></a>16.分离式编译</h2><p>c++支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern int i;    //声明而非定义</span><br><span class="line">int j;    //声明并定义</span><br><span class="line">extern double pi = 3.14159;    //定义</span><br></pre></td></tr></table></figure>

<p>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。<br>如果要在多个文件中使用同一个变量，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>
<h2 id="17-标识符"><a href="#17-标识符" class="headerlink" title="17.标识符"></a>17.标识符</h2><p>必须以字母或下划线开头<br>用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头<br>定义在函数体外的标识符不能以下划线开头</p>
<h2 id="18-嵌套的作用域"><a href="#18-嵌套的作用域" class="headerlink" title="18.嵌套的作用域"></a>18.嵌套的作用域</h2><p>使用<a href="https://blog.csdn.net/qq_33266987/article/details/53689133" target="_blank" rel="noopener"><strong>作用域运算符</strong>（<strong>::</strong>）</a><br>在本例中表示显式地访问全局变量<br>eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int reused = 42;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int unique = 0;</span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	int reused = 0;</span><br><span class="line">	//使用局部变量reused，此时变量in scope</span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	//显式访问全局变量reused</span><br><span class="line">	std::cout &lt;&lt; ::reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">42 0</span><br><span class="line">0 0</span><br><span class="line">42 0</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>9.11更</li>
</ul>
<h2 id="19-引用（-amp-d，d是声明的变量）"><a href="#19-引用（-amp-d，d是声明的变量）" class="headerlink" title="19.引用（&amp;d，d是声明的变量）"></a>19.引用（&amp;d，d是声明的变量）</h2><p>定义引用时，程序把引用和它的初始值<strong>绑定（bind）</strong>在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。</p>
<hr>
<ul>
<li>9.12放假划水了一天… </li>
<li>9.13更</li>
</ul>
<h2 id="20-空指针"><a href="#20-空指针" class="headerlink" title="20.空指针"></a>20.空指针</h2><p>几种生成空指针的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = nullptr;</span><br><span class="line">int *p2 = 0;</span><br><span class="line">//需要首先#include cstdlib</span><br><span class="line">int *p3 = NULL;</span><br></pre></td></tr></table></figure>

<p><strong>NULL</strong>是一个预处理变量，在头文件cstdlib中定义。预处理变量不属于命名空间std。<br>在C++11新标准下，最好使用<strong>nullptr</strong>，同时尽量避免使用NULL。<br>把int变量直接赋给指针是错误的操作。</p>
<h2 id="21-赋值永远改变的是等号左侧的对象"><a href="#21-赋值永远改变的是等号左侧的对象" class="headerlink" title="21.赋值永远改变的是等号左侧的对象"></a>21.赋值永远改变的是等号左侧的对象</h2><p>尤其是对于指针这种，很容易迷惑<br>eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *pi = 0;  //pi被初始化为0</span><br><span class="line">pi = &amp;ival;  //pi指向ival</span><br><span class="line">*pi = 0;  //(*pi即pi指向的对象)ival发生改变</span><br></pre></td></tr></table></figure>

<h2 id="22-两指针比较"><a href="#22-两指针比较" class="headerlink" title="22.两指针比较"></a>22.两指针比较</h2><p>类型相同的指针比较结果为布尔型。<br>两个指针存放的地址值相同有三种可能：<br>1.它们都为空<br>2.都指向同一个对象<br>3.<strong>一个指针指向某对象，同时另一个指针指向另外对象的下一地址</strong></p>
<h2 id="23-void-指针"><a href="#23-void-指针" class="headerlink" title="23.void* 指针"></a>23.void* 指针</h2><p>void*能存放任意类型对象的地址。他能做的就是：和其他指针比较、作为函数输入输出、赋给另外一个void*指针。不能直接操作</p>
<h2 id="24-指向指针的引用"><a href="#24-指向指针的引用" class="headerlink" title="24.指向指针的引用"></a>24.指向指针的引用</h2><p>好复杂… 昏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">int *p;</span><br><span class="line">int *&amp;r = p;  //r是一个对指针p的引用</span><br><span class="line"></span><br><span class="line">r = &amp;i;  //r引用了一个指针，给r赋值&amp;i就是令p指向i</span><br><span class="line">*r = 0;  //解引用r得到i，也就是p指向的对象，将i的值改为0</span><br></pre></td></tr></table></figure>

<p>（从右向左阅读有助于弄清复杂指针或引用的声明语句的真实含义）</p>
<h2 id="25-const限定符"><a href="#25-const限定符" class="headerlink" title="25.const限定符"></a>25.const限定符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize = 512;</span><br></pre></td></tr></table></figure>

<p>const对象一旦创建后，任何试图为bufSize赋值的行为都将引发错误。所以const对象必须初始化。初始值可以是任意复杂的表达式。</p>
<blockquote>
<p>const学的非常不好…可以回头再多看看</p>
</blockquote>
<h2 id="26-const的引用"><a href="#26-const的引用" class="headerlink" title="26.const的引用"></a>26.const的引用</h2><p>与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const int ci = 1024;</span><br><span class="line">const int &amp;r1 = ci;</span><br><span class="line"></span><br><span class="line">r1 = 42;  //错误，r1是对常量的引用</span><br><span class="line">const int &amp;r = r1;  //合法，但是不允许通过r修改r1</span><br><span class="line">int &amp;r2 = ci;  //错误，试图让一个非常量引用指向一个常量对象==&gt;尤其容易搞错</span><br></pre></td></tr></table></figure>

<p>假设第四句是合法的，则可以通过r2来改变它引用对象的值，这显然不正确。</p>
<h2 id="27-指针和const"><a href="#27-指针和const" class="headerlink" title="27.指针和const"></a>27.指针和const</h2><p>指针的类型必须与其所指对象的类型一致，但有两个意外。<br>1.允许一个指向常量的指针指向一个非常量对象。<br>2.</p>
<p>引用的类型必须与其所引用对象的类型一致，但有两个例外。<br>1.在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。<br>2.</p>
<h2 id="28-非常量引用不能引用字面值常量"><a href="#28-非常量引用不能引用字面值常量" class="headerlink" title="28.非常量引用不能引用字面值常量"></a>28.非常量引用不能引用字面值常量</h2><h2 id="29-顶层-amp-amp-底层"><a href="#29-顶层-amp-amp-底层" class="headerlink" title="29.顶层 &amp;&amp; 底层"></a>29.顶层 &amp;&amp; 底层</h2><p>顶层const：表示指针本身是一个常量。可以表示任意的对象是常量，对任何数据类型都适用。<br>底层const：表示指针所指的对象是一个常量。与指针和引用等复合类型的基本类型部分有关。</p>
<h2 id="30-constexpr和常量表达式"><a href="#30-constexpr和常量表达式" class="headerlink" title="30.constexpr和常量表达式"></a>30.constexpr和常量表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int max_files = 20;    //是常量表达式</span><br><span class="line">const int limit = max_files + 1;    //是</span><br><span class="line">int staff_size = 27;    //不是</span><br><span class="line">const int sz = get_size();    //不是</span><br></pre></td></tr></table></figure>

<p>其中staff_size的初始值是一个字面值常量，但是它只是一个普通的int，而非const int，所以不属于常量表达式。<br>sz本身是一个常量，但是它的具体值直到运行时才能获取到，所以不是常量表达式。<br>C++11规定，允许将变量声明为<strong>constexpr</strong>类型以便由编译器来验证变量的值是否是一个常量表达式。尽管不能使用普通的函数作为constexpr变量的初始值，但允许用constexpr函数（足够简单以使得编译时就可以计算其结果）去初始化constexpr变量。<br>而声明constexpr时用到的类型称为“字面值类型”<br>一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p>
<h2 id="31-定义类型别名"><a href="#31-定义类型别名" class="headerlink" title="31.定义类型别名"></a>31.定义类型别名</h2><p>1.使用关键字<strong>typedef</strong><br>2.使用别名声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using SI = Sales_item;    //SI是Sales_item的同义词</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>9.14更（今天又出去玩了…）<blockquote>
<p>p61需要再研究</p>
</blockquote>
</li>
</ul>
<h2 id="32-auto类型说明符"><a href="#32-auto类型说明符" class="headerlink" title="32.auto类型说明符"></a>32.auto类型说明符</h2><p>能让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。所以，auto定义的变量必须有初始值。<br>如果使用auto在一条语句中声明多个变量，则要保证该语句中所有变量的初始基本数据类型都一样。</p>
<h2 id="33-decltype类型指示符"><a href="#33-decltype类型指示符" class="headerlink" title="33.decltype类型指示符"></a>33.decltype类型指示符</h2><p>作用：选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。<br>eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(f()) sum = x;  //sum的类型就是函数f()的返回类型</span><br></pre></td></tr></table></figure>

<p>如果decltype使用的表达式是一个变量，则返回该变量的类型（包括顶层const和引用在内）。<br>如果decltype使用的变量加上了一层或多层括号，编译器就会把他当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型。<br>eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decltype((i)) d;  //错误，d是int&amp;，必须初始化</span><br><span class="line">decltype (i) d;  //正确，d是int</span><br></pre></td></tr></table></figure>

<blockquote>
<p>decltype((variable))的结果永远是引用，而decltype(variable)的结果只有当var本身是引用时才是引用。</p>
</blockquote>
<hr>
<ul>
<li>9.25更</li>
</ul>
<p>从第五空间线下回来了…好菜…又刷了点pwn题，继续哈~</p>
<h2 id="34-预处理器"><a href="#34-预处理器" class="headerlink" title="34.预处理器"></a>34.预处理器</h2><p>从c语言继承而来，确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong><br>预处理功能<br>1.<strong>#include</strong>：用指定的头文件的内容代替#include<br>2.<strong>头文件保护符</strong>：依赖于预处理变量。<strong>#define</strong>把一个名字设定为预处理变量，<strong>#ifdef</strong>当且仅当变量已定义时为真，<strong>#ifndef</strong>当且仅当变量未定义时为真。一旦检查为真，则执行后续操作直至遇到<strong>#endif</strong>为止。</p>
<blockquote>
<p>程序员一般习惯性的加上头文件保护符，不太在乎程序是否需要</p>
</blockquote>
<h2 id="35-抽象数据类型库"><a href="#35-抽象数据类型库" class="headerlink" title="35.抽象数据类型库"></a>35.抽象数据类型库</h2><p>string和vector是两种最重要的标准库类型，前者支持可变长字符串，后者表示可变长的集合。还有一种标准库类型是迭代器，它是string和vector的配套类型，常被用于访问string中的字符或vector中的元素。</p>
<h2 id="36-using"><a href="#36-using" class="headerlink" title="36.using"></a>36.using</h2><p>我们用到的库函数基本都属于命名空间std，同时使用作用域操作符（::）<br>简单途径就是 使用<strong>using声明</strong>使用到命名空间的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace::name;</span><br></pre></td></tr></table></figure>

<p>用到的每个名字都必须有自己的声明语句，分号结束。</p>
<p>头文件不应包含using声明</p>
<h2 id="37-include"><a href="#37-include" class="headerlink" title="37.#include"></a>37.#include<string></string></h2><p>可以定义很多种<strong>初始化string对象</strong>的方法=.=【使用等号（=）执行<strong>拷贝初始化</strong>，否则为<strong>直接初始化</strong>】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1;    //默认初始化，s1是一个空字符串</span><br><span class="line">string s2(s1);    //s2是s1的副本</span><br><span class="line">string s2 = s1;    //等价于s2(s1)</span><br><span class="line">string s3(&quot;value&quot;);    //s3是字面值“value”的副本，除了字面值最后的那个空字符串</span><br><span class="line">string s3 = &quot;value&quot;;    //等价于s3(&quot;value&quot;)，s3是字面值“value”的副本</span><br><span class="line">string s4(n, &apos;c&apos;);    //把s4初始化为由连续n个字符c组成的串</span><br></pre></td></tr></table></figure>

<p><strong>string对象上的操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os&lt;&lt;s;    //将s写到输出流os当中，返回os</span><br><span class="line">is&gt;&gt;s;    //从is中读取字符串赋给s，字符串以空白分隔，返回is</span><br><span class="line">getline(is, s);    //从is中读取一行赋给s，返回is</span><br><span class="line">s.empty();    //s为空返回true，否则返回false</span><br><span class="line">s.size();    //返回s中字符的个数</span><br></pre></td></tr></table></figure>

<p>string对象会自动忽略开头的空白（即空格符、换行符、制表符等），并从第一个真正的字符开始读起，直到遇见下一处空白为止。</p>
<hr>
<ul>
<li>9.26更<h2 id="38-getline"><a href="#38-getline" class="headerlink" title="38.getline"></a>38.getline</h2></li>
</ul>
<p><strong>getline</strong>函数从给定输入流中读入内容，直到遇到换行符为止（<strong>换行符也被读进来了</strong>），如果输入的一开始就是换行符，那么所得的结果是个空string。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line">//每次读入一整行，直至到达文件末尾</span><br><span class="line">while(getline(cin, line))</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>empty函数</strong>：根据string对象是否为空返回一个对应的布尔值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//每次读入一行，遇到空行直接跳过</span><br><span class="line">while(getline(cin, line))</span><br><span class="line">     if(!line.empty())</span><br><span class="line">          cout &lt;&lt; line &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>size函数</strong>：返回string对象的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(getline(cin, line))</span><br><span class="line">     if(line.size() &gt; 80)</span><br><span class="line">          cout &lt;&lt; line &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>size函数返回的是一个<strong>string::size_type</strong>类型。它是一个无符号类型的值而且能够存放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string::size_type类型。</p>
<p>C++11新标准中，允许编译器通过auto或者decltype来推断变量的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto len = line. size();    //len的类型是string::size_type</span><br></pre></td></tr></table></figure>

<p>假设n是一个负值int，则表达式s. size() &lt; n的判断结果几乎肯定是true。这是因为负值n会自动地转换成一个比较大的无符号值。</p>
<p>tips：如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。</p>
<p><strong>string对象的比较</strong>依照字典顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = &quot;hello&quot;;     //3</span><br><span class="line">string phrase = &quot;hello world&quot;;     //2</span><br><span class="line">string slang = &quot;hiya&quot;;     //1</span><br></pre></td></tr></table></figure>

<p><strong>两个string对象相加</strong>使用（+）（+=）直接串接而成。</p>
<p><strong>字面值和string对象相加</strong>：必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strjng s1 = &quot;hello&quot;;</span><br><span class="line">string s = s1 + &quot;,&quot; + &quot; world&quot;;</span><br><span class="line">//正确</span><br></pre></td></tr></table></figure>

<h2 id="39-处理string中的字符"><a href="#39-处理string中的字符" class="headerlink" title="39.处理string中的字符"></a>39.处理string中的字符</h2><p><strong>cctype头文件中的函数</strong>：过多… 用到时查一下，记住常用的好了。</p>
<p><strong>使用c++版本的c标准库头文件</strong>：c语言头文件形如<em>name.h</em>，c++将这些文件命名为<em>cname</em>，c表示这是一个属于c语言的头文件。</p>
<h2 id="40-范围for语句"><a href="#40-范围for语句" class="headerlink" title="40.范围for语句"></a>40.范围for语句</h2><p>for(<em>declaration</em> : <em>expression</em>)<br>&#160;&#160;&#160;&#160;&#160;&#160;  <em>statement</em></p>
<p>其中，<em>expression</em>部分是一个对象，用于表示一个序列。<em>declaration</em>部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，<em>declaration</em>部分的变量会<strong>被初始化为expression部分的下一个元素值</strong>。</p>
<p>访问string对象中的单个字符有两种方式，一种是使用下标运算符（<strong>[ ]</strong>），另一种是使用迭代器。<br>注意下标的设置，因为c++标准并不要求标准库检测下标是否合法。</p>
<hr>
<ul>
<li>9.28更</li>
</ul>
<h2 id="41-标准库类型vector"><a href="#41-标准库类型vector" class="headerlink" title="41.标准库类型vector"></a>41.标准库类型vector</h2><p><strong>vector</strong>表示对象的集合，其中所有对象的类型都相同。它也常被称为<strong>容器</strong>。<br>要使用vector必须包含适当的头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;vector&gt;</span><br><span class="line">using std::vector;</span><br></pre></td></tr></table></figure>

<p>C++语言既有类模板，也有函数模板。其中vector是一个类模板。编译器根据模板创建类或函数的过程称为<strong>实例化</strong>，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec;    //ivec保存int类型的对象</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; files;    //该向量的元素是vector对象</span><br></pre></td></tr></table></figure>

<p>vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。<br>早期版本C++标准：vector&lt;vector<int> &gt; //======&gt;外层添加一个空格<br>C++11标准：vector&lt;vector<int>&gt;<br><strong>初始化vector对象的方法</strong><br>|||<br>-|-|<br>vector<t> v1| v1是一个空vector，它潜在的元素是T类型的，执行默认初始化|<br>vector<t> v2(v1) | v2中包含v1所有元素的副本 |<br>vector<t> v2 = v1 | 等价于上一条 |<br>vector<t> v3(n, val) | v3包含了n个重复的元素，每个元素的值都是val |<br>vector<t> v4(n) | v4包含了n个重复地执行了<strong>值初始化的</strong>对象|<br>vector<t> v5{a, b, c … } | v5包含了初始值个数的元素，每个元素被赋予相应的初始值|<br>vector<t> v5 = {a, b, c … } | 等价于上一条—&gt;<strong>列表初始化</strong>|<br>可以选择初始化为空，或者进行拷贝。 如果vector对象中的元素的类型不支持默认初始化，我们就必须提供初始化的元素值。</t></t></t></t></t></t></t></int></int></p>
<p>可以通过花括号（<strong>{ }</strong>）和圆括号（<strong>( )</strong>）来区别是列表初始化还是元素数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v1(10);    //v1有10个元素，每个元素的值都是0</span><br><span class="line">vector&lt;int&gt; v2&#123;10&#125;;    //v2有1个元素，值为10</span><br><span class="line">vector&lt;int&gt; v3(10, 1);    //v3有10个元素，每个的值都是1</span><br><span class="line">vector&lt;int&gt; v4&#123;10, 1&#125;;    //v4有两个元素，值分别是10和1</span><br></pre></td></tr></table></figure>

<p>但如果初始化时<strong>使用了花括号的形式</strong>但是提供的值又<strong>不能用来列表初始化</strong>，就要考虑用这样的值来构造vector对象了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v5(&quot;hi&quot;);    //列表初始化，v5有一个元素</span><br><span class="line">vector&lt;string&gt; v6&#123;&quot;hi&quot;&#125;;    //错误：不能使用字符串字面值构建vector对象</span><br><span class="line">vector&lt;string&gt; v7&#123;10&#125;;    //v7有10个默认初始化的元素</span><br><span class="line">vector&lt;string&gt; v8&#123;10， ”hi“&#125;;    //v8有10个值为“hi”的元素</span><br></pre></td></tr></table></figure>

<p><strong>vector的成员函数push_back</strong>：负责把一个值当成vector对象的尾元素“压到（push）”vector对象的“尾端（back）”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string word;</span><br><span class="line">vector&lt;string&gt; text;</span><br><span class="line">while(cin &gt;&gt; word)&#123;</span><br><span class="line">  text.push_back(word);    //将word添加到text后面</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>范围for语句体内不应改变其所遍历序列的大小。</p>
</blockquote>
<p>除了push_back外，vector还提供了几种其他操作，大多与string类似。</p>
<blockquote>
<p>vector对象及string对象的下标运算可用于访问已存在的元素，而不能用于添加元素。对于vector对象，正确的方法是使用push_back。</p>
</blockquote>
<p>关于下标必须明确的一点是：只能对确知已存在的元素执行下标操作。</p>
<hr>
<ul>
<li>9.30更<h2 id="42-迭代器"><a href="#42-迭代器" class="headerlink" title="42.迭代器"></a>42.迭代器</h2>有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。</li>
</ul>
<p>和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。这些类型都拥有名为<strong>begin</strong>和<strong>end</strong>的成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//b表示v的第一个元素，e表示v尾元素的下一位置</span><br><span class="line">auto b = v. begin(),  e = v.end();</span><br></pre></td></tr></table></figure>

<p>尾后迭代器（尾迭代器）没有什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。<br>如果容器为空，则begin和end返回的是<strong>同一个迭代器</strong>，都是尾后迭代器。<br><strong>标准容器迭代器的运算符</strong>与C类似，见到就能懂是干嘛的。</p>
<blockquote>
<p>C++程序员习惯性使用!=或==，是因为所有标准库容器都定义了他们，而大多数没有定义&lt;运算符。</p>
</blockquote>
<h2 id="43"><a href="#43" class="headerlink" title="43."></a>43.</h2>  
	  </div>
		  <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/笔记/">笔记</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/笔记/">笔记</a><a href="/tags/C/">C++</a>
  </div>

</div>



</footer>

   	       
	  </article>
	  
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/10/03/Asis CTF 2016 b00ks(obo)/wp/" title="Asis CTF 2016 b00ks wp (null off-by-one)【详】">
  <span>
  Asis CTF 2016 b00ks wp (null off-by-one)【详】</span>
</a>
</div>


<div class="next">
<a href="/2019/10/03/【攻防世界】pwn进阶区/【攻防世界】pwn进阶区wp/"  title="【攻防世界】pwn进阶区 wp(未完)">
 <span>【攻防世界】pwn进阶区 wp(未完)
</span>
</a>
</div>

</nav>

	  

</div> 
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		<a href="http://weibo.com/https://weibo.com/u/5213203661?refer_flag=0000015010_&amp;from=feed&amp;loc=nickname" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/https://github.com/p1Kk" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:p1kk_wang@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/ACM/" title="ACM">ACM<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/CTF/" title="CTF">CTF<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/oj/" title="oj">oj<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/笔记/" title="笔记">笔记<sup>9</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/pwn/" title="pwn">pwn<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/wp/" title="wp">wp<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/笔记/" title="笔记">笔记<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/堆/" title="堆">堆<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/攻防世界/" title="攻防世界">攻防世界<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C++">C++<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/AWD/" title="AWD">AWD<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ubuntu18/" title="ubuntu18">ubuntu18<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/HDU/" title="HDU">HDU<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/IO/" title="IO">IO<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/canary/" title="canary">canary<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="link1's url" target="_blank" title="link1&#39;s name">link1&#39;s name</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	

	<p class="copyright">
	Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2019 
	
	<a href="/about" target="_blank" title="p1Kk">p1Kk</a>
	
	
	</p>
</div></footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
